<template>
  <AppPaneLayout layout-id="mqtt">
    <template #primary>
      <div
        class="sticky top-0 z-10 flex flex-shrink-0 p-4 overflow-x-auto space-x-2 bg-primary hide-scrollbar"
      >
        <div class="inline-flex flex-1 space-x-2">
          <div class="flex flex-1">
            <input
              id="mqtt-url"
              v-model="url"
              type="url"
              autocomplete="off"
              :class="{ error: !isUrlValid }"
              class="flex flex-1 w-full px-4 py-2 border rounded-l bg-primaryLight border-divider text-secondaryDark"
              :placeholder="`${t('mqtt.url')}`"
              :disabled="
                connectionState === 'CONNECTED' ||
                connectionState === 'CONNECTING'
              "
              @keyup.enter="isUrlValid ? toggleConnection() : null"
            />
            <label
              for="client-id"
              class="px-4 py-2 font-semibold truncate border-t border-b bg-primaryLight border-divider text-secondaryLight"
            >
              {{ t("mqtt.client_id") }}
            </label>
            <input
              id="client-id"
              v-model="clientID"
              class="flex flex-1 w-full px-4 py-2 border rounded-r bg-primaryLight border-divider text-secondaryDark"
              spellcheck="false"
              :disabled="
                connectionState === 'CONNECTED' ||
                connectionState === 'CONNECTING'
              "
              @keyup.enter="isUrlValid ? toggleConnection() : null"
            />
          </div>
          <ButtonPrimary
            id="connect"
            :disabled="!isUrlValid"
            class="w-32"
            :label="
              connectionState === 'DISCONNECTED'
                ? t('action.connect')
                : t('action.disconnect')
            "
            :loading="connectionState === 'CONNECTING'"
            @click.native="toggleConnection"
          />
        </div>
      </div>

      <div
        class="flex flex-col flex-1"
        :hidden="connectionState === 'CONNECTED'"
      >
        <RealtimeConnectionConfig @change="onChangeConfig" />
      </div>
      <RealtimeCommunication
        v-if="connectionState === 'CONNECTED'"
        :show-event-field="currentTabId === 'all'"
        :is-connected="connectionState === 'CONNECTED'"
        @send-message="
          publish(
            currentTabId === 'all'
              ? $event
              : {
                  message: $event.message,
                  eventName: currentTabId,
                }
          )
        "
      />
    </template>

    <template #secondary>
      <SmartWindows
        :id="'communication_tab'"
        v-model="currentTabId"
        @removeTab="removeTab"
        @sort="sortTabs"
      >
        <template v-for="tab in tabs">
          <SmartWindow
            :id="tab.id"
            :key="'removable_tab_' + tab.id"
            :label="tab.name"
            :is-removable="tab.removable"
            :icon="'square'"
            :icon-color="tab.color"
            class="flex flex-col flex-1 overflow-y-auto"
          >
            <RealtimeLog
              :title="t('mqtt.log')"
              :log="tab.id === 'all' ? logs : currentTabLogs"
              @delete="clearLogEntries()"
            />
          </SmartWindow>
        </template>
      </SmartWindows>
    </template>

    <template #sidebar>
      <div
        class="sticky z-10 flex flex-col border-b rounded-t divide-y divide-dividerLight bg-primary border-dividerLight"
      >
        <div class="flex justify-between flex-1">
          <ButtonSecondary
            svg="plus"
            :label="t('mqtt.new')"
            class="!rounded-none"
            @click.native="showSubscriptionModal(true)"
          />
          <span class="flex">
            <ButtonSecondary
              v-tippy="{ theme: 'tooltip' }"
              to="https://docs.hoppscotch.io/features/mqtt"
              blank
              :title="t('app.wiki')"
              svg="help-circle"
            />
          </span>
        </div>
      </div>

      <div
        v-if="topics.length === 0"
        class="flex flex-col items-center justify-center p-4 text-secondaryLight"
      >
        <img
          :src="`/images/states/${$colorMode.value}/pack.svg`"
          loading="lazy"
          class="inline-flex flex-col object-contain object-center w-16 h-16 my-4"
          :alt="`${t('empty.subscription')}`"
        />
        <span class="pb-4 text-center">
          {{ t("empty.subscription") }}
        </span>
        <ButtonSecondary
          :label="t('mqtt.new')"
          filled
          @click.native="showSubscriptionModal(true)"
        />
      </div>

      <div v-else>
        <div
          v-for="(topic, index) in topics"
          :key="`subscription-${index}`"
          class="flex flex-col"
        >
          <div class="flex items-stretch group">
            <span class="flex items-center justify-center px-4 cursor-pointer">
              <SmartIcon
                class="svg-icons"
                name="square"
                :style="{
                  fill: topic.color,
                  color: topic.color,
                }"
              />
            </span>
            <span
              class="flex flex-1 min-w-0 py-2 pr-2 cursor-pointer transition group-hover:text-secondaryDark"
              @click="openTopicAsTab(topic)"
            >
              <span class="truncate">
                {{ topic.name }}
              </span>
            </span>
            <ButtonSecondary
              v-tippy="{ theme: 'tooltip' }"
              svg="trash"
              color="red"
              :title="t('mqtt.unsubscribe')"
              class="hidden group-hover:inline-flex"
              data-testid="unsubscribe_mqtt_subscription"
              @click.native="unsubscribeFromTopic(topic.name)"
            />
          </div>
        </div>
      </div>

      <RealtimeSubscription
        :show="subscriptionModalShown"
        :loading-state="subscribing"
        @submit="subscribeToTopic"
        @hide-modal="showSubscriptionModal(false)"
      />
    </template>
  </AppPaneLayout>
</template>

<script setup lang="ts">
import {
  computed,
  onMounted,
  onUnmounted,
  ref,
  watch,
} from "@nuxtjs/composition-api"
import debounce from "lodash/debounce"
import {
  MQTTConnection,
  MQTTConnectionConfig,
  MQTTError,
  MQTTTopic,
} from "~/helpers/realtime/MQTTConnection"
import {
  HoppRealtimeLog,
  HoppRealtimeLogLine,
} from "~/helpers/types/HoppRealtimeLog"
import {
  useI18n,
  useNuxt,
  useReadonlyStream,
  useStream,
  useStreamSubscriber,
  useToast,
} from "~/helpers/utils/composables"
import {
  addMQTTLogLine,
  MQTTConn$,
  MQTTEndpoint$,
  MQTTClientID$,
  MQTTLog$,
  setMQTTConn,
  setMQTTEndpoint,
  setMQTTClientID,
  setMQTTLog,
} from "~/newstore/MQTTSession"

const t = useI18n()
const nuxt = useNuxt()
const toast = useToast()
const { subscribeToStream } = useStreamSubscriber()
const url = useStream(MQTTEndpoint$, "", setMQTTEndpoint)
const clientID = useStream(MQTTClientID$, "", setMQTTClientID)
const config = ref<MQTTConnectionConfig>()
const logs = useStream(MQTTLog$, [], setMQTTLog)
const currentTabLogs = ref<HoppRealtimeLog>([])
const socket = useStream(MQTTConn$, new MQTTConnection(), setMQTTConn)
const connectionState = useReadonlyStream(
  socket.value.connectionState$,
  "DISCONNECTED"
)
const subscriptionState = useReadonlyStream(
  socket.value.subscriptionState$,
  false
)
const subscribing = useReadonlyStream(socket.value.subscribing$, false)
const isUrlValid = ref(true)
const subTopic = ref("")
let worker: Worker
const subscriptionModalShown = ref(false)
const canSubscribe = computed(() => connectionState.value === "CONNECTED")
const topics = useReadonlyStream(socket.value.subscribedTopics$, [])

const currentTabId = ref("all")
const defaultTab = {
  id: "all",
  name: "All Topics",
  color: "var(--accent-color)",
  removable: false,
}
const tabs = ref([defaultTab])
watch(currentTabId, (tabID) => {
  if (tabID !== "all") {
    currentTabLogs.value = logs.value.filter((log) => {
      return log.prefix?.includes(tabID)
    })
  }
})

const onChangeConfig = (e: MQTTConnectionConfig) => {
  config.value = e
}

const showSubscriptionModal = (show: boolean) => {
  subscriptionModalShown.value = show
}
const workerResponseHandler = ({
  data,
}: {
  data: { url: string; result: boolean }
}) => {
  if (data.url === url.value) isUrlValid.value = data.result
}
onMounted(() => {
  worker = nuxt.value.$worker.createRejexWorker()
  worker.addEventListener("message", workerResponseHandler)
  subscribeToStream(socket.value.event$, (event) => {
    switch (event?.type) {
      case "CONNECTING":
        logs.value = [
          {
            payload: `${t("state.connecting_to", { name: url.value })}`,
            source: "info",
            color: "var(--accent-color)",
            ts: undefined,
          },
        ]
        break
      case "CONNECTED":
        logs.value = [
          {
            payload: `${t("state.connected_to", { name: url.value })}`,
            source: "info",
            color: "var(--accent-color)",
            ts: Date.now(),
          },
        ]
        toast.success(`${t("state.connected")}`)
        break
      case "MESSAGE_SENT":
        addLog({
          prefix: `${event.message.topic}`,
          payload: event.message.message,
          source: "client",
          ts: Date.now(),
        })
        break
      case "MESSAGE_RECEIVED":
        addLog({
          prefix: `${event.message.topic}`,
          payload: event.message.message,
          source: "server",
          ts: event.time,
        })
        break
      case "SUBSCRIBED":
        showSubscriptionModal(false)
        addMQTTLogLine({
          payload: subscriptionState.value
            ? `${t("state.subscribed_success", { topic: event.topic })}`
            : `${t("state.unsubscribed_success", { topic: event.topic })}`,
          source: "server",
          ts: event.time,
        })
        break
      case "SUBSCRIPTION_FAILED":
        addMQTTLogLine({
          payload: subscriptionState.value
            ? `${t("state.subscribed_failed", { topic: subTopic.value })}`
            : `${t("state.unsubscribed_failed", { topic: subTopic.value })}`,
          source: "server",
          ts: event.time,
        })
        break
      case "ERROR":
        addMQTTLogLine({
          payload: getI18nError(event.error),
          source: "info",
          color: "#ff5555",
          ts: event.time,
        })
        break
      case "DISCONNECTED":
        addMQTTLogLine({
          payload: t("state.disconnected_from", { name: url.value }).toString(),
          source: "info",
          color: "#ff5555",
          ts: event.time,
        })
        toast.error(`${t("state.disconnected")}`)
        break
    }
  })
})
const addLog = (line: HoppRealtimeLogLine) => {
  if (currentTabId.value !== "all") {
    currentTabLogs.value.push(line)
  }
  addMQTTLogLine(line)
}
const debouncer = debounce(function () {
  worker.postMessage({ type: "ws", url: url.value })
}, 1000)
watch(url, (newUrl) => {
  if (newUrl) debouncer()
})
onUnmounted(() => {
  worker.terminate()
})
// METHODS
const toggleConnection = () => {
  // If it is connecting:
  if (connectionState.value === "DISCONNECTED") {
    return socket.value.connect(url.value, clientID.value, config.value)
  }
  // Otherwise, it's disconnecting.
  socket.value.disconnect()
}
const publish = (event: { message: string; eventName: string }) => {
  socket.value?.publish(event.eventName, event.message)
}
const subscribeToTopic = (topic: MQTTTopic) => {
  if (canSubscribe.value) {
    if (topics.value.some((t) => t.name === topic.name)) {
      return toast.error(t("mqtt.already_subscribed").toString())
    }
    socket.value.subscribe(topic)
  } else {
    subscriptionModalShown.value = false
    toast.error(t("mqtt.not_connected").toString())
  }
}
const unsubscribeFromTopic = (topic: string) => {
  socket.value.unsubscribe(topic)
}
const getI18nError = (error: MQTTError): string => {
  if (typeof error === "string") return error
  switch (error.type) {
    case "CONNECTION_NOT_ESTABLISHED":
      return t("state.connection_lost").toString()
    case "SUBSCRIPTION_FAILED":
      return t("state.mqtt_subscription_failed", {
        topic: error.topic,
      }).toString()
    case "PUBLISH_ERROR":
      return t("state.publish_error", { topic: error.topic }).toString()
    case "CONNECTION_LOST":
      return t("state.connection_lost").toString()
    case "CONNECTION_FAILED":
      return t("state.connection_failed").toString()
    default:
      return t("state.disconnected_from", { name: url.value }).toString()
  }
}
const clearLogEntries = () => {
  logs.value = []
}
const changeTab = (id: string) => {
  currentTabId.value = id
}
const openTopicAsTab = (topic: MQTTTopic) => {
  const { name, color } = topic
  if (tabs.value.some((tab) => tab.id === topic.name)) {
    return changeTab(topic.name)
  }
  tabs.value.push({
    id: name,
    name,
    color,
    removable: true,
  })
  changeTab(topic.name)
}

const sortTabs = (e: { oldIndex: number; newIndex: number }) => {
  const newTabs = [...tabs.value]
  newTabs.splice(e.newIndex, 0, newTabs.splice(e.oldIndex, 1)[0])
  tabs.value = newTabs
}

const removeTab = (tabID: string) => {
  const index = tabs.value.findIndex((tab) => tab.id === tabID)
  tabs.value.splice(index, 1)
}
</script>
